<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Advanced Page Replacement Algorithm Visualizer</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600;700&display=swap" rel="stylesheet">
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<style>
    :root {
        --bg-dark: #0f172a;
        --bg-light: #1e293b;
        --primary: #38bdf8;
        --primary-light: #7dd3fc;
        --text-light: #f8fafc;
        --text-dark: #0f172a;
        --green: #22c55e;
        --red: #ef4444;
        --yellow: #facc15;
        --purple: #a78bfa;
    }

    body {
        font-family: 'Poppins', sans-serif;
        background-color: var(--bg-dark);
        color: var(--text-light);
        margin: 0;
        padding: 20px;
    }

    .container {
        max-width: 1100px;
        margin: 0 auto;
        display: grid;
        gap: 25px;
    }

    header { text-align: center; }

    h1 {
        color: var(--primary);
        font-weight: 700;
        margin-bottom: 5px;
    }
    
    header p { margin-top: 0; color: var(--primary-light); }

    .card {
        background: var(--bg-light);
        padding: 20px;
        border-radius: 12px;
        box-shadow: 0 4px 15px rgba(0,0,0,0.2);
    }

    .controls {
        display: grid;
        gap: 15px;
        grid-template-columns: 1fr 1fr;
    }

    .controls input {
        padding: 10px;
        border-radius: 8px;
        border: 2px solid transparent;
        background-color: #334155;
        color: var(--text-light);
        font-size: 16px;
        grid-column: 1 / -1;
        transition: border-color 0.3s;
    }
    .controls input:focus { outline: none; border-color: var(--primary); }

    .button-group {
        grid-column: 1 / -1;
        display: flex;
        justify-content: center;
        flex-wrap: wrap;
        gap: 10px;
    }

    button {
        background-color: var(--primary);
        border: none;
        padding: 10px 20px;
        border-radius: 8px;
        color: var(--text-dark);
        font-weight: bold;
        cursor: pointer;
        transition: background-color 0.3s, transform 0.2s;
    }

    button:hover:not(:disabled) {
        background-color: var(--primary-light);
        transform: translateY(-2px);
    }
    
    button:disabled { background-color: #475569; cursor: not-allowed; }

    button.secondary { background-color: #475569; color: var(--text-light); }
    button.secondary:hover:not(:disabled) { background-color: #64748b; }
    
    button.analysis { background-color: var(--purple); color: var(--text-light); }
    button.analysis:hover:not(:disabled) { background-color: #c084fc; }


    .speed-control {
        grid-column: 1 / -1;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 10px;
    }
    
    .speed-control input[type="range"] { width: 200px; }

    h2 {
        color: var(--primary-light);
        margin-top: 0;
        border-bottom: 1px solid #334155;
        padding-bottom: 10px;
    }

    .status-bar {
        font-size: 1.2em;
        font-weight: 600;
        text-align: center;
        margin-bottom: 20px;
        min-height: 30px;
    }
    
    .status-bar span { margin: 0 15px; }
    .status-bar .faults { color: var(--red); }
    .status-bar .hits { color: var(--green); }

    .frame-container {
        display: flex;
        justify-content: center;
        gap: 10px;
        min-height: 80px;
        padding: 10px;
        background: #0f172a;
        border-radius: 8px;
    }

    .frame {
        background-color: var(--bg-light);
        border: 2px solid var(--primary);
        border-radius: 10px;
        width: 60px;
        height: 60px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 22px;
        font-weight: bold;
        transition: all 0.4s ease;
    }
    
    .frame.hit {
        background-color: var(--green);
        color: var(--text-dark);
        transform: scale(1.15);
        border-color: #fff;
    }

    .frame.fault { background-color: var(--red); animation: shake 0.5s; }
    
    @keyframes shake {
        0%, 100% { transform: translateX(0); } 25% { transform: translateX(-5px); } 75% { transform: translateX(5px); }
    }

    #log {
        margin-top: 20px; font-family: 'Courier New', monospace; font-size: 0.95em;
        white-space: pre-wrap; text-align: left; background: #0f172a;
        padding: 15px; border-radius: 8px; min-height: 150px;
        max-height: 300px; overflow-y: auto;
    }
    
    #log .log-entry { padding: 2px 0; }

    /* New Comparison Table Styles */
    #comparisonResult table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 15px;
    }
    #comparisonResult th, #comparisonResult td {
        padding: 12px;
        text-align: center;
        border: 1px solid #334155;
    }
    #comparisonResult th { background-color: #334155; }
    #comparisonResult tr.best { background-color: #166534; font-weight: bold; }

    /* New Timeline Styles */
    #timelineContainer { overflow-x: auto; padding: 10px; background: #0f172a; border-radius: 8px; }
    .timeline-table { border-collapse: collapse; white-space: nowrap; margin: 10px 0; }
    .timeline-table th, .timeline-table td {
        border: 1px solid #334155;
        padding: 8px;
        width: 40px;
        height: 40px;
        text-align: center;
        font-family: 'Courier New', monospace;
    }
    .timeline-table th { background-color: #334155; }
    .timeline-table td.header { background-color: #334155; font-weight: bold; }
    .timeline-table td.fault { background-color: var(--red); color: var(--text-light); }
    .timeline-table td.hit { background-color: var(--green); color: var(--text-dark); }
    .timeline-table td.stale { color: #64748b; }

    details { background: var(--bg-dark); border-radius: 8px; margin-bottom: 10px; border: 1px solid #334155; }
    summary { padding: 15px; font-weight: 600; cursor: pointer; color: var(--primary-light); }
    .concept-content { padding: 0 20px 20px 20px; text-align: left; line-height: 1.6; }
    .concept-content strong { color: var(--primary); }
</style>
</head>
<body>

<div class="container">
    <header>
        <h1>Advanced Page Replacement Algorithm Visualizer</h1>
        <p>An interactive tool to understand and analyze FIFO, LRU, and Optimal algorithms</p>
    </header>

    <div class="card controls">
        <input id="pages" placeholder="Enter page reference string, e.g., 7,0,1,2,0,3,0,4,2,3,0,3,2" />
        <input id="frames" type="number" placeholder="Enter number of frames for simulation, e.g., 4" />
        
        <div class="button-group">
            <button id="fifoBtn">Simulate FIFO</button>
            <button id="lruBtn">Simulate LRU</button>
            <button id="optimalBtn">Simulate Optimal</button>
        </div>
        <div class="button-group">
             <button id="randomBtn" class="secondary">Generate Random</button>
             <button id="resetBtn" class="secondary">Reset All</button>
        </div>
       
        <div class="speed-control">
            <label for="speed">Animation Speed:</label>
            <input id="speed" type="range" min="50" max="1500" value="700" step="50" />
        </div>
    </div>

    <div id="visualizer" class="card">
        <h2>Live Visualizer</h2>
        <div class="status-bar">
            Current Page: <span id="currentPage">-</span> |
            Hits: <span id="hits" class="hits">0</span> |
            Faults: <span id="faults" class="faults">0</span>
        </div>
        <div id="frameContainer" class="frame-container"></div>
    </div>
    
    <div id="output" class="card">
        <h2>Execution Log</h2>
        <div id="log">Welcome! Enter data, then select a simulation or analysis option.</div>
    </div>

    <div id="analysis" class="card">
        <h2>Analysis & Comparison</h2>
        <div class="button-group">
            <button id="compareBtn" class="analysis">Compare All Algorithms</button>
            <button id="beladyBtn" class="analysis">Analyze Belady's Anomaly (FIFO)</button>
        </div>
        <div id="comparisonResult"></div>
        <div id="beladyAnalysis" style="margin-top: 20px;">
            <canvas id="beladyChart"></canvas>
        </div>
    </div>

    <div id="timeline" class="card">
        <h2>Simulation Timeline</h2>
        <div id="timelineContainer">Select a simulation to generate its timeline view here.</div>
    </div>

    <div id="concepts" class="card">
        <h2>Algorithm Concepts</h2>
        <details>
            <summary>First-In, First-Out (FIFO)</summary>
            <div class="concept-content">
                <p>FIFO is the simplest page replacement algorithm. It works just like a queue. When a page fault occurs, it replaces the page that has been in memory for the <strong>longest time</strong>.</p>
                <p><strong>Key Point:</strong> It can suffer from <strong>Belady's Anomaly</strong>, where increasing the number of frames might paradoxically increase the page fault rate. Our analyzer can help you spot this!</p>
            </div>
        </details>
        <details>
            <summary>Least Recently Used (LRU)</summary>
            <div class="concept-content">
                <p>LRU operates on the principle of locality of reference. When a page fault occurs, it replaces the page that has <strong>not been used for the longest amount of time</strong>. It performs well but is more complex to implement than FIFO.</p>
            </div>
        </details>
        <details>
            <summary>Optimal (OPT / MIN)</summary>
            <div class="concept-content">
                <p>The Optimal algorithm is the gold standard. It replaces the page that will <strong>not be used for the longest period in the future</strong>. It guarantees the minimum possible number of page faults but is impossible to implement in a real system as it requires future knowledge.</p>
            </div>
        </details>
    </div>
</div>

<script>
document.addEventListener('DOMContentLoaded', () => {
    // --- Element References ---
    const pagesInput = document.getElementById('pages');
    const frameCountInput = document.getElementById('frames');
    const fifoBtn = document.getElementById('fifoBtn');
    const lruBtn = document.getElementById('lruBtn');
    const optimalBtn = document.getElementById('optimalBtn');
    const randomBtn = document.getElementById('randomBtn');
    const resetBtn = document.getElementById('resetBtn');
    const compareBtn = document.getElementById('compareBtn');
    const beladyBtn = document.getElementById('beladyBtn');
    const speedSlider = document.getElementById('speed');

    const frameContainer = document.getElementById('frameContainer');
    const logContainer = document.getElementById('log');
    const currentPageEl = document.getElementById('currentPage');
    const hitsEl = document.getElementById('hits');
    const faultsEl = document.getElementById('faults');
    const comparisonResultEl = document.getElementById('comparisonResult');
    const beladyChartCanvas = document.getElementById('beladyChart');
    const timelineContainerEl = document.getElementById('timelineContainer');

    let isSimulating = false;
    let beladyChartInstance = null;

    // --- Event Listeners ---
    fifoBtn.addEventListener('click', () => runAnimatedSimulation('FIFO'));
    lruBtn.addEventListener('click', () => runAnimatedSimulation('LRU'));
    optimalBtn.addEventListener('click', () => runAnimatedSimulation('Optimal'));
    compareBtn.addEventListener('click', compareAll);
    beladyBtn.addEventListener('click', analyzeBelady);
    resetBtn.addEventListener('click', resetUI);
    randomBtn.addEventListener('click', generateRandomString);

    // --- Core Simulation Logic (No UI) ---
    function runSimulationLogic(type, pages, frameCount) {
        let frames = [];
        let hits = 0;
        let faults = 0;
        let fifoPointer = 0;
        const timelineSteps = [];

        for (let i = 0; i < pages.length; i++) {
            const page = pages[i];
            let hit = frames.includes(page);
            let event = '';

            if (hit) {
                hits++;
                event = 'hit';
                if (type === 'LRU') {
                    const index = frames.indexOf(page);
                    frames.splice(index, 1);
                    frames.push(page);
                }
            } else {
                faults++;
                event = 'fault';
                if (frames.length < frameCount) {
                    frames.push(page);
                } else {
                    if (type === 'FIFO') {
                        frames[fifoPointer] = page;
                        fifoPointer = (fifoPointer + 1) % frameCount;
                    } else if (type === 'LRU') {
                        frames.shift();
                        frames.push(page);
                    } else if (type === 'Optimal') {
                        const future = pages.slice(i + 1);
                        let victimIndex = -1;
                        let farthest = -1;

                        frames.forEach((f, idx) => {
                            const futureIndex = future.indexOf(f);
                            if (futureIndex === -1) {
                                victimIndex = idx;
                                return;
                            }
                            if (futureIndex > farthest) {
                                farthest = futureIndex;
                                victimIndex = idx;
                            }
                        });
                        if (victimIndex !== -1) {
                            frames[victimIndex] = page;
                        } else {
                             frames[0] = page; // fallback
                        }
                    }
                }
            }
            // Record state for timeline
            const stepState = {
                page: page,
                frames: [...frames],
                event: event
            };
            timelineSteps.push(stepState);
        }
        return { hits, faults, timelineSteps };
    }

    // --- Animated Simulation (With UI) ---
    async function runAnimatedSimulation(type) {
        if (isSimulating) return;

        const { pages, frameCount } = getInputs();
        if (!pages) return;

        isSimulating = true;
        toggleControls(false);
        resetUI(false);

        const simulationResult = runSimulationLogic(type, pages, frameCount);
        const timelineSteps = simulationResult.timelineSteps;

        logMessage(`--- Starting ${type} Simulation ---`, 'info');
        await sleep();

        let currentHits = 0;
        let currentFaults = 0;

        for (let i = 0; i < timelineSteps.length; i++) {
            const step = timelineSteps[i];
            currentPageEl.textContent = step.page;
            
            if (step.event === 'hit') {
                currentHits++;
                logMessage(`\nStep ${i+1}: Page ${step.page} -> Hit`, 'hit');
            } else {
                currentFaults++;
                logMessage(`\nStep ${i+1}: Page ${step.page} -> Fault`, 'fault');
            }

            hitsEl.textContent = currentHits;
            faultsEl.textContent = currentFaults;
            updateFramesUI(step.frames, step.page, step.event === 'hit');
            await sleep();
        }

        logMessage(`\n--- Simulation Complete ---`, 'info');
        logMessage(`Total Hits: ${currentHits}, Total Faults: ${currentFaults}`);
        
        generateTimeline(pages, timelineSteps, frameCount);
        currentPageEl.textContent = 'Done';
        toggleControls(true);
        isSimulating = false;
    }

    // --- New Analysis Functions ---
    function compareAll() {
        const { pages, frameCount } = getInputs();
        if (!pages) return;

        logMessage("\n--- Running Full Comparison ---", 'info');

        const results = [
            { name: 'FIFO', ...runSimulationLogic('FIFO', pages, frameCount) },
            { name: 'LRU', ...runSimulationLogic('LRU', pages, frameCount) },
            { name: 'Optimal', ...runSimulationLogic('Optimal', pages, frameCount) },
        ];

        let best = results.reduce((prev, current) => (prev.faults < current.faults) ? prev : current);

        let tableHTML = `
            <table>
                <tr><th>Algorithm</th><th>Page Faults</th><th>Hits</th><th>Hit Ratio</th></tr>
        `;
        results.forEach(res => {
            const hitRatio = (res.hits / pages.length * 100).toFixed(2);
            const isBest = res.name === best.name ? 'class="best"' : '';
            tableHTML += `
                <tr ${isBest}>
                    <td>${res.name}</td>
                    <td>${res.faults}</td>
                    <td>${res.hits}</td>
                    <td>${hitRatio}%</td>
                </tr>`;
        });
        tableHTML += '</table>';
        comparisonResultEl.innerHTML = tableHTML;
    }

    function analyzeBelady() {
        const { pages } = getInputs(false); // No frame count needed
        if (!pages) return;

        logMessage("\n--- Analyzing Belady's Anomaly for FIFO ---", 'info');
        const maxFrames = Math.max(10, new Set(pages).size + 2);
        const labels = [];
        const data = [];

        for (let i = 1; i <= maxFrames; i++) {
            const result = runSimulationLogic('FIFO', pages, i);
            labels.push(i);
            data.push(result.faults);
        }

        if (beladyChartInstance) {
            beladyChartInstance.destroy();
        }

        beladyChartInstance = new Chart(beladyChartCanvas, {
            type: 'line',
            data: {
                labels: labels,
                datasets: [{
                    label: 'Page Faults',
                    data: data,
                    borderColor: 'rgb(239, 68, 68)',
                    backgroundColor: 'rgba(239, 68, 68, 0.5)',
                    tension: 0.1,
                    fill: false
                }]
            },
            options: {
                responsive: true,
                plugins: {
                    title: { display: true, text: "FIFO: Page Faults vs. Number of Frames" }
                },
                scales: {
                    x: { title: { display: true, text: 'Number of Frames' } },
                    y: { title: { display: true, text: 'Total Page Faults' } }
                }
            }
        });
    }
    
    function generateTimeline(pages, timelineSteps, frameCount) {
        let tableHTML = `<table class="timeline-table"><thead><tr><th>Frame #</th>`;
        pages.forEach(p => tableHTML += `<th>${p}</th>`);
        tableHTML += `</tr></thead><tbody>`;

        for (let i = 0; i < frameCount; i++) {
            tableHTML += `<tr><td class="header">Frame ${i}</td>`;
            timelineSteps.forEach(step => {
                const pageInFrame = step.frames[i];
                let cellClass = '';
                if (pageInFrame !== undefined) {
                    if (step.page === pageInFrame && step.event === 'hit') {
                        cellClass = 'hit';
                    } else if (step.page === pageInFrame && step.event === 'fault') {
                        cellClass = 'fault';
                    } else {
                        cellClass = 'stale';
                    }
                    tableHTML += `<td class="${cellClass}">${pageInFrame}</td>`;
                } else {
                    tableHTML += `<td>-</td>`;
                }
            });
            tableHTML += `</tr>`;
        }
        tableHTML += `</tbody></table>`;
        timelineContainerEl.innerHTML = tableHTML;
    }


    // --- UI and Helper Functions ---
    function getInputs(requireFrameCount = true) {
        const pagesStr = pagesInput.value;
        const frameCount = parseInt(frameCountInput.value);

        if (requireFrameCount && (isNaN(frameCount) || frameCount <= 0)) {
             logMessage('Error: A positive number of frames is required for this action.', 'error');
             return {};
        }

        if (!pagesStr) {
            logMessage('Error: Please enter a valid page reference string.', 'error');
            return {};
        }

        const pages = pagesStr.split(',').map(x => parseInt(x.trim())).filter(x => !isNaN(x));
        if (pages.length === 0) {
            logMessage('Error: The page reference string is invalid.', 'error');
            return {};
        }
        return { pages, frameCount };
    }

    function updateFramesUI(currentFrames, currentPage, isHit) {
        frameContainer.innerHTML = '';
        currentFrames.forEach(f => {
            const div = document.createElement('div');
            div.classList.add('frame');
            div.innerText = f;
            if (f === currentPage) {
                div.classList.add(isHit ? 'hit' : 'fault');
            }
            frameContainer.appendChild(div);
        });
    }
    
    function logMessage(message, type = 'default') {
        const entry = document.createElement('div');
        entry.textContent = message;
        if (type === 'hit') entry.style.color = 'var(--green)';
        if (type === 'fault') entry.style.color = 'var(--red)';
        if (type === 'info') entry.style.color = 'var(--primary-light)';
        if (type === 'error') entry.style.color = 'var(--yellow)';
        logContainer.appendChild(entry);
        logContainer.scrollTop = logContainer.scrollHeight;
    }

    function toggleControls(enable) {
        const buttons = document.querySelectorAll('button');
        buttons.forEach(btn => btn.disabled = !enable);
        pagesInput.disabled = !enable;
        frameCountInput.disabled = !enable;
    }

    function resetUI(clearInputs = true) {
        if (clearInputs) {
            pagesInput.value = '';
            frameCountInput.value = '';
        }
        frameContainer.innerHTML = '';
        logContainer.innerHTML = 'Welcome! Enter data, then select a simulation or analysis option.';
        hitsEl.textContent = '0';
        faultsEl.textContent = '0';
        currentPageEl.textContent = '-';
        comparisonResultEl.innerHTML = '';
        timelineContainerEl.innerHTML = 'Select a simulation to generate its timeline view here.';
        if (beladyChartInstance) {
            beladyChartInstance.destroy();
            beladyChartInstance = null;
        }
    }
    
    function generateRandomString() {
        const length = 20;
        const pageRange = 10;
        const randomPages = Array.from({ length }, () => Math.floor(Math.random() * pageRange));
        pagesInput.value = randomPages.join(',');
        frameCountInput.value = Math.floor(Math.random() * 3) + 3;
    }

    function sleep() {
        const ms = 1550 - speedSlider.value;
        return new Promise(resolve => setTimeout(resolve, ms));
    }
});
</script>
</body>
</html>
